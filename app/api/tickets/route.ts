import { NextRequest, NextResponse } from 'next/server';
import { supabase } from '@/lib/supabase';
import { createTicketSchema } from '@/lib/schemas';
import { checkRateLimit, getClientIP, RATE_LIMITS, rateLimitResponse } from '@/lib/rate-limit';

export async function POST(request: NextRequest) {
    try {
        // Rate limiting
        const ip = getClientIP(request);
        const { allowed, resetIn } = checkRateLimit(
            `createTicket:${ip}`,
            RATE_LIMITS.createTicket
        );

        if (!allowed) {
            return rateLimitResponse(resetIn);
        }

        const body = await request.json();

        // Validate input
        const result = createTicketSchema.safeParse(body);
        if (!result.success) {
            return NextResponse.json(
                {
                    error: 'Datos inválidos',
                    details: result.error.flatten().fieldErrors
                },
                { status: 400 }
            );
        }

        const data = result.data;

        // Prepare ticket data based on type
        const ticketData: Record<string, unknown> = {
            type: data.type,
            full_name: data.full_name,
            phone: data.phone,
            email: data.email || null,
            address: data.address,
            postal_code: data.postal_code || null,
            source: 'web',
            ip_address: ip,
        };

        if (data.type === 'contract') {
            // Get promo notes if sent from frontend
            const promoNotes = (body as any).promo_notes;

            Object.assign(ticketData, {
                community: data.community || null,
                municipality: data.municipality || null,
                references_text: data.references_text || null,
                package_id: data.package_id || null,
                preferred_schedule: data.preferred_schedule || null,
                contract_status: 'NEW',
                // Store promo info in public_note (visible column in tickets table)
                public_note: promoNotes || null,
            });
        } else {
            Object.assign(ticketData, {
                service_number: data.service_number || null,
                fault_description: data.fault_description,
                fault_status: 'NEW',
            });
        }

        // Insert ticket (folio is auto-generated by trigger)
        const { data: ticket, error } = await supabase
            .from('tickets')
            .insert(ticketData)
            .select('id, folio, type, full_name, created_at')
            .single();

        if (error) {
            console.error('Error creating ticket:', error);
            console.error('Error details:', JSON.stringify(error, null, 2));
            return NextResponse.json(
                {
                    error: 'Error al crear la solicitud',
                    details: error.message,
                    code: error.code,
                    hint: error.hint
                },
                { status: 500 }
            );
        }

        // Create initial status history entry
        await supabase.from('ticket_status_history').insert({
            ticket_id: ticket.id,
            new_status: data.type === 'contract' ? 'NEW' : 'NEW',
            change_reason: 'Solicitud creada desde sitio web',
        });

        // Return success with folio
        return NextResponse.json({
            success: true,
            folio: ticket.folio,
            type: ticket.type,
            message: data.type === 'contract'
                ? '¡Tu solicitud de contratación ha sido recibida!'
                : '¡Tu reporte de falla ha sido recibido!',
            tracking_url: `/public/seguimiento?folio=${ticket.folio}`,
        });

    } catch (error) {
        console.error('Unexpected error:', error);
        return NextResponse.json(
            { error: 'Error inesperado. Por favor intenta de nuevo.' },
            { status: 500 }
        );
    }
}

// GET endpoint for admin to list tickets
export async function GET(request: NextRequest) {
    try {
        const { searchParams } = new URL(request.url);
        const type = searchParams.get('type') || 'contract';
        const status = searchParams.get('status');
        const page = parseInt(searchParams.get('page') || '1');
        const limit = parseInt(searchParams.get('limit') || '20');
        const search = searchParams.get('search');

        let query = supabase
            .from('tickets')
            .select('*', { count: 'exact' })
            .eq('type', type)
            .order('created_at', { ascending: false })
            .range((page - 1) * limit, page * limit - 1);

        if (status) {
            if (type === 'contract') {
                query = query.eq('contract_status', status);
            } else {
                query = query.eq('fault_status', status);
            }
        }

        if (search) {
            query = query.or(`folio.ilike.%${search}%,full_name.ilike.%${search}%,phone.ilike.%${search}%`);
        }

        const { data: tickets, error, count } = await query;

        if (error) {
            console.error('Error fetching tickets:', error);
            return NextResponse.json(
                { error: 'Error al obtener tickets' },
                { status: 500 }
            );
        }

        return NextResponse.json({
            data: tickets,
            pagination: {
                page,
                limit,
                total: count || 0,
                totalPages: Math.ceil((count || 0) / limit),
            },
        });

    } catch (error) {
        console.error('Unexpected error:', error);
        return NextResponse.json(
            { error: 'Error inesperado' },
            { status: 500 }
        );
    }
}
